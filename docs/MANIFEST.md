Manifest format and provenance

This project writes a manifest JSON file for every pipeline run. The manifest captures provenance (what was fetched, environment details and output hashes) and supports optional HMAC signing for reproducibility.

Top-level fields

- run_id: string
  - If `MANIFEST_SIGNING_KEY` is set, `run_id` is a deterministic HMAC-SHA256 hex digest over a canonical JSON slice of the manifest (see `manifest_signature` below). If not set, a UUIDv4 is used.
- manifest_signature: string (optional)
  - Present only when `MANIFEST_SIGNING_KEY` is set. This is the same value as `run_id` and is computed as HMAC-SHA256(signing_key, canonical_payload).
- run_timestamp_utc: string (ISO8601)
  - Time of the run (timezone-aware UTC). Not used in the signature to keep signature deterministic.
- environment: object
  - python_version: runtime Python version
  - platform: platform string
  - pip_freeze: result of `pip freeze` at runtime
  - git_commit: git commit hash if available
- fetch_summary: object
  - Aggregated counts of rows per source (e.g., {"WB": 2150})
- fetches: array
  - Per-request metadata entries. Each entry typically contains:
    - url / resource: the API endpoint or SDMX resource
    - params: request parameters used
    - status_code (when applicable)
    - response_time_ms (when applicable)
    - rows: number of rows returned by this request
    - sha256_raw: sha256 over the canonical JSON of the pulled rows for provenance
    - api_meta: API-specific metadata (pagination, lastupdated, etc.)
- outputs: object
  - Mapping of logical output name (e.g., "excel") to a dict with `path` and `sha256` of the written file.
- n_rows: integer
  - Total number of rows across all fetched data.
- config_snapshot: object
  - The serialized runtime configuration used for the run.

Stable payload used for deterministic signature

To compute a deterministic HMAC signature the writer builds a stable payload containing only the input-like fields that should be stable across identical runs: `['config_snapshot', 'fetch_summary', 'fetches', 'n_rows', 'outputs']`. The canonical JSON is produced with `sort_keys=True` and separators `(',', ':')` to ensure deterministic byte representation. The HMAC uses the `MANIFEST_SIGNING_KEY` as the secret.

Verifying a manifest signature

1. Extract the stable fields from the manifest: `config_snapshot`, `fetch_summary`, `fetches`, `n_rows`, `outputs`.
2. Serialize them as canonical JSON: `json.dumps(payload, sort_keys=True, separators=(',', ':'), ensure_ascii=False).encode('utf-8')`.
3. Compute `hmac.new(signing_key.encode('utf-8'), canonical, hashlib.sha256).hexdigest()` and compare to `manifest_signature`.

Notes & best practices

- Store the `MANIFEST_SIGNING_KEY` securely (e.g., in an environment variable in CI/CD secrets). Do not check it into source control.
- If you rely on caching, cached fetches also continue to emit `fetch_logs` that were stored when the data was originally fetched â€” this preserves provenance even for cache hits.
- The manifest writer intentionally excludes ephemeral fields (like `run_timestamp_utc` and `environment`) from the signed payload to make signatures stable across identical data runs.

Example

See `data/_artifacts/manifest_YYYYMMDDTHHMMSSZ.json` generated by the pipeline for a real example.
